#summary Brain dump while thinking about the structure of transitfeed.py
#labels Phase-Design

= Things to validate =

In sections that could be checked at the same time, starting with low level byte things, working towards high level where relations between multiple rows or objects matter.

== File format ==
  * correct eol
  * valid utf-8
  * correct csv format
  * same number of columns on each line

== GTFS tables ==
  * all required tables present
  * in each present table the required columns are present
  * warn about unknown tables
  * warn about unknown columns

== Individual values ==

These can be checked when parsing a row from a table or when assigning a value to an attribute.
  * correct format for type. Is it a valid time, date, float etc?
  * in valid range, abs(latitude) < 90, abs(longitude) < 180

Instances of classes such as `Stop` can be in many states:
  * Initialized from a list of unicode strings in a file
  * No attributes set
  * Attribute assigned in the normal python manner, `stop.stop_lat = 45.832`
  * Attribute assigned as a string (probably doesn't need to be supported

The advantage of storing a string for each value and lazily converting to a native type later is that __init__ is fast and doesn't fail. Also if __getitem__ always returns a string one can treat the object as a dict, which feels clean. But if the strings are saved in __dict__ I need to use __getattribute__ to intercept requests so that, for example, stop.stop_lat returns a float instead of unicode. __getattribute__ is slow because it is called a lot, even for self.__dict__ and self.Validate(). Strings could be saved in a separate dict which could be consulted by __getattr__.

== Consistent row/object ==

These could be checked during __init__, if it is given all values which happens in the common case of loading from a file. Checking in __setattr__ doesn't seem like a great idea because the order that attributes are set may determine if a problem is reported. For example location_type and parent_id would need to be changed atomically.

  * arr and dep time both present or absent
  * stop not near 0,0
  * parent_id only set with correct location_type
  * route_short_name not in route_long_name

== Good ids ==

Many tables refer to ids found elsewhere in a GTFS feed. If everything was in a SQL DB it might make sense to check using SQL instead of in each objects Validate method. Here is a subset of things to check:

   * No duplicate stop_id in stops, trip_id in trips etc
   * No duplicate (trip_id, stop_sequence) tuples in stop_times
   * trips: route_id, shape_id, service_id
   * stops: parent_id is the id of another stop
   * stop_times: the current sqlite branch does not check that all stop_times entries contain a valid stop_id and trip_id and there is no test

== Other multirow checks ==

  * For a trip
    * first and last stop_time have a time
    * speeding legs, a sign of teleportation
    * frequency periods, if present, are disjoint
  * warn about stops within 2m that are not related in stop hierarchy
  * illogical fares
  * warn about unused stops